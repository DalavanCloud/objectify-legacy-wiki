#summary Defining and registering entities

Objectify is similar to ORM systems like Hibernate - it maps between the datastore and your typed, Java POJOs.  There are two steps:  First define your domain model in Java using Objectify's annotations, then register these classes with the {{{ObjectifyFactory}}}.

= Defining Entities =

Entities are simple Java POJOs with a handful of special annotations.  Objectify has its own annotations and *does NOT use JPA or JDO annotations*.

Note that throughout this documentation we will leave off getter and setter methods for brevity.

== The Basics ==

Here is a minimal entity class:

{{{
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Ignore;
import 

@Entity
public class Car {
    @Id Long id;
    String vin;
    int color;
    byte[] rawData;
    @Ignore irrelevant;

    private Car() {}
    
    public Car(String vin, int color) {
        this.vin = vin;
        this.color = color;
    }
}
}}}

Observe:

  * Entity classes must be annotated with {{{@Entity}}}.

  * Objectify persists fields and only fields.  It does not arbitrarily map fields to the datastore; if you want to change the way a field is stored, rename the field.  Getters and setters are ignored so you can isolate the public interface of your class (eg, {{{public String getVehicleIdentificationNumber() { return vin; }}}}).

 * Objectify will not persist {{{static}}} fields, {{{final}}} fields, or fields annotated with {{{@Ignore}}}.  It *will* persist fields with the {{{transient}}} keyword, which only affects serialization.

  * Entities must have have one field annotated with {{{@Id}}}.  The actual name of the field is irrelevant and can be renamed at any time, even after data is persisted.  This value (along with the kind 'Car') becomes part of the {{{Key}}} which identifies an entity.

  * The {{{@Id}}} field can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and save an entity with a null id, a numeric value will be generated for you using the standard GAE allocator for this kind.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

  * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], Collections (ie Lists and Sets) of the core value types, or arrays of the core value types.  You can also persist properties of type {{{Key}}} (the native datastore type) and {{{Key<?>}}}) (the Objectify generified version).  There are more advanced types that can be persisted which will be discussed later.

  * There must be a no-arg constructor (or no constructors - Java creates a default no-arg constructor).  The no-arg constructor can have any protection level (private, public, etc).

  * {{{String}}} fields which store more than 500 characters (the GAE limit) are automatically converted to {{{Text}}} internally.  Note that {{{Text}}} fields, like {{{Blob}}} fields, are never indexed (see [Queries]).

  * {{{byte[]}}} fields are automatically converted to {{{Blob}}} internally.  However, {{{Byte[]}}} is persisted "normally" as an array of (potentially indexed) {{{Byte}}} objects.  Note that GAE natively stores all integer values as a 64-bit long.

= Registering Entities =