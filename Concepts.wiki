#summary Fundamental Concepts of the Datastore
#labels Featured

This is a combined introduction to Objectify and to the Appengine datastore.

<wiki:toc max_depth="1" />

So, you want to persist some data.  You've probably looked at the [http://code.google.com/appengine/docs/java/datastore/overview.html datastore documentation] and thought "crap, that's complicated!"  Entities, query languages, fetch groups, detaching, transactions... hell those things have bloody _lifecycles_!  However, the complexity of JDO is hiding a lot of simplicity under the covers.  

= Entities =

This document will talk a lot about entities.  An _entity_ is an object's worth of data in the datastore.  Using Objectify, an entity will correspond to a single POJO class you define.  In the datastore, an entity is a HashMap-like object of type Entity.  Conceptually, they are the same.

= Operations =

There are only four basic operations in the datastore, and any persistence API must boil operations down to:

  * *get()* an entity whole from the datastore.  You can get many at a time.
  * *put()* an entity whole in the datastore.  You can store many at a time.
  * *delete()* an entity from the datastore.  (You guessed it) You can delete many at a time.
  * *prepare()* a Query, which searches the datastore for entities matching criteria you define.

= Keys =

All entities have either a Long *id* or a String *name*, but those values are not unique by themselves.  In the datastore, entities are identified by the id (or name) and a *kind*, which corresponds to the type of object you are storing.  So, to get Car #959 from the datastore, you need to call something equivalent to {{{get_from_datastore("Car", 959)}}} (not real code yet).

By the way, I lied.  There is actually a third value which is necessary to uniquely identify an entity, called *parent*.  Parent defines a special kind of relationship, placing the child in the same [http://code.google.com/appengine/docs/python/datastore/keysandentitygroups.html entity group] as the parent.  Entity groups will be discussed next in the section on Transactions, but for now what you need to know is that this parent (which is often simply null) is also required to uniquely identify an entity.  So, to get Car #959 from the datastore, you actually need to call something equivalent to {{{get_from_datastore("Car", 959, null)}}} or {{{get_from_datastore("Car", 959, theOwner)}}}.  Yeech.

Instead of passing three parameters around all the time, the datastore wraps these values into a single object - a _Key_.  That's all a {{{Key}}} is, a holder for the three parts that uniquely identify an entity.

The native Datastore {{{Key}}} class is simple and untyped, like the native {{{Entity}}} objects.  Objectify uses a generified class called {{{OKey}}} instead.  It works nearly identically to native keys, but carries type information:

{{{
OKey<Car> rootKey = new OKey<Car>(Car.class, 959);
OKey<Car> keyWithParent = new OKey<Car>(parent, Car.class, 959);
}}}

With an {{{OKey}}} you can use the most fundamental method on the {{{Objectify}}} interface, nearly identical to the {{{DatastoreService}}} equivalent.  If the generics are confusing, hold on - there will be examples later.

{{{
<T> T get(OKey<? extends T> key) throws EntityNotFoundException;
}}}

In Objectify, you define your object as a Java class with a mandatory identifier (Long, long, or String) and an optional parent.  However, when you look up or reference your object, you do so by _OKey_.  In fact, you can (and should) batch together a variety of requests into a single call, even if it will fetch many different kinds of objects:

{{{
Map<OKey<Object>, Object> lotsOfThings = objectify.get(carKey, airplaneKey, chairKey, personKey, yourMamaKey);
}}}

Actually, I lied again.  We don't force you to create keys by hand all the time.  There is a convenient shorthand for the very common case of loading a single type of object, but don't forget that this is really just creating an {{{OKey}}} and calling get()!

{{{
Car c = objectify.get(Car.class, 959);
Map<OKey<Car>, Car> cars = objectify.get(Car.class, 959, 911, 944, 924);
}}}

By the way, {{{OKey}}} is used for relationship references as well.  Remember that value that defines a parent entity?  The type of this parent is {{{OKey}}}:

{{{
public OKey(OKey<?> parent, Class<? extends T> kind, long id)
}}}

When you create relationships to other entities in your system, the type of the entity relationship should be {{{OKey}}}.

= Transactions =

The datastore has a lot of odd concepts designed to facilitate building a JTA interface - thread local transactions, implicit transaction management policies, and methods that behave differently whether you pass them a transaction or not.  Forget all that.  Here's what you need to know:

== Entity Groups ==

When you put() your entity, it gets stored somewhere in a gigantic farm of thousands of machines.  In order to perform an atomic transaction, the datastore (currently) requires that all the data that is a part of that transaction live on the same server.  To give you some control over where your data is stored, the datastore has the concept of an *entity group*.

Remember the _parent_ that is part of a {{{OKey}}}?  If an entity has a parent, it belongs to the same entity group as its parent.  If an entity does not have a parent, it is the "root" of an entity group, and may be physically located anywhere in the cluster.

Within a transaction, you can only access data from a single entity group.  If you try to access data from multiple entity groups, you will get an Exception.  This means you must pick your entity groups carefully, usually to correspond to the data associated with a single user.  Yes, this severely limits the utility of transactions.

Why not store all your data with a common parent, putting it all in a single entity group?  You can, but it's a bad idea.  Google limits the number of requests per second that can be served by a particular entity group.

It should be worth mentioning that the term _parent_ is somewhat misleading.  There is no "cascading delete" in the datastore; if you delete the parent entity it will NOT delete the child entities.  For that matter, you can create child entites with a parent {{{Key}}} (or any other key as a member field) that points to a nonexistant entity!  Parent is only important in that it defines entity groups; if you do not need transactions across several entities, you may wish to use a normal nonparent key relationship - even if the entities have a conceptual parent-child relationship.

== Executing Transactions ==

When you execute a {{{get()}}}, {{{put()}}}, {{{delete()}}}, or {{{prepare(Query)}}}, you will either be in a [http://code.google.com/appengine/docs/java/datastore/transactions.html transaction] or you will not.

If you execute within a transaction:
  * You must only get/put/delete/query objects within a single entity group.
  * All operations will either succeed completely or fail completely.
  * get() and query operations will see the database as if it were frozen in time at the start of the transaction.  They will not even reflect put()s and delete()s you perform _within the transaction_.
  * If another process modifies your data before you commit, your datastore operations will fail with a {{{ConcurrentModificationException}}}

If you execute without a transaction:
  * All individual datastore operations are treated separately.
  * Any changes to the datastore made anywhere will have immediate effect - successive get() operations may return different values.
  * If there is contention, operations will be automatically retried until the operation succeeds or the system gives up.

= Indexes =

Indexes are used to query for data.  In the datastore, queries can only follow a single index and can only return results in the order specified for that index.  This means that you must have an index for every query you intend to run!

To make this easier, the datastore has an innate ability to store each and every (single) property as "indexed" or "unindexed" ({{{Entity.setProperty()}}} vs {{{Entity.setUnindexedProperty()}}}.  This allows you to easily issue a queries based on single properties.  By default, Objectify defaults to setting all properties as indexed unless you flag the field with an {{{@Unindexed}}} annotation.

To run queries by filtering against multiple properties, you must create a multi-value index in your {{{datastore-indexes.xml}}}.  There is a great deal written on this subject; we recommend [http://code.google.com/appengine/articles/storage_breakdown.html How Entities and Indexes are Stored] and [http://code.google.com/appengine/articles/index_building.html Index Building].

-----

Now that you are familiar with the underlying concepts of the datastore, read the IntroductionToObjectify.