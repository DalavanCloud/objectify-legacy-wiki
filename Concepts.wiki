#summary Fundamental Concepts of the Datastore
#labels Featured

This is a combined introduction to Objectify and to the Appengine datastore.

<wiki:toc max_depth="1" />

So, you want to persist some data.  You've probably looked at the [http://code.google.com/appengine/docs/java/datastore/overview.html datastore documentation] and thought "crap, that's complicated!"  Entities, query languages, fetch groups, detaching, transactions... hell those things have bloody _lifecycles_!  However, the complexity of JDO is hiding a lot of simplicity under the covers.  

= Entities =

This document will talk a lot about entities.  An _entity_ is an object's worth of data in the datastore.  Using Objectify, an entity will correspond to a single POJO class you define.  In the datastore, an entity is a HashMap-like object of type Entity.  Conceptually, they are the same.

= Operations =

There are only four basic operations in the datastore, and any persistence API must boil operations down to:

  * *get()* an entity whole from the datastore.  You can get many at a time.
  * *put()* an entity whole in the datastore.  You can store many at a time.
  * *delete()* an entity from the datastore.  (You guessed it) You can delete many at a time.
  * *prepare()* a Query, which searches the datastore for entities matching criteria you define.

= Keys =

All entities have either a Long *id* or a String *name*, but those values are not unique by themselves.  In the datastore, entities are identified by the id (or name) and a *kind*, which corresponds to the type of object you are storing.  So, to get Car #959 from the datastore, you need to call something equivalent to {{{get_from_datastore("Car", 959)}}} (not real code yet).

By the way, I lied.  There is actually a third value which is necessary to uniquely identify an entity, called *parent*.  Parent defines a special kind of relationship, placing the child in the same [http://code.google.com/appengine/docs/python/datastore/keysandentitygroups.html entity group] as the parent.  Entity groups will be discussed next in the section on Transactions, but for now what you need to know is that this parent (which is often simply null) is also required to uniquely identify an entity.  So, to get Car #959 from the datastore, you actually need to call something equivalent to {{{get_from_datastore("Car", 959, null)}}} or {{{get_from_datastore("Car", 959, myPrivateCollection)}}}.  Yeech.

Instead of passing three parameters around all the time, the datastore wraps these values into a single object - a _Key_.  That's all a {{{Key}}} is, a holder for the three parts that uniquely identify an entity.  You can create them like this:

{{{
Key rootKey = ObjectifyFactory.createKey(Car.class, 959);
Key keyWithParent = ObjectifyFactory.createKey(parent, Car.class, 959);
}}}

With a {{{Key}}} you can use the most fundamental method on the {{{Objectify}}} interface, nearly identical to the {{{DatastoreService}}} equivalent:

{{{
<T> T get(Key key) throws EntityNotFoundException;
}}}

In Objectify, you define your object as a Java class with a mandatory identifier (Long, long, or String) and an optional parent.  However, when you lookup or reference your object, you do so by _Key_.  In fact, you can (and should) batch together a variety of requests into a single call, even if it will fetch many different kinds of objects:

{{{
Map<Key, Object> lotsOfThings = objectify.get(carKey, airplaneKey, chairKey, personKey, yourMamaKey);
}}}

Actually, I lied again.  We don't force you to create keys by hand all the time.  There is a convenient shorthand for the very common case of loading a single type of object, but don't forget that this is really just creating a {{{Key}}} and calling get()!

{{{
Car c = objectify.get(Car.class, 959);
Map<Key, Car> cars = objectify.get(Car.class, 959, 911, 944, 924);
}}}

By the way, {{{Key}}} is used for relationship references as well.  Remember that value that defines a parent entity?  The type of this parent is {{{Key}}}:

{{{
public static Key ObjectifyFactory.createKey(Key parent, Class<?> kind, long id)
}}}

When you create relationships to other entities in your system, the type of the entity relationship should be {{{Key}}}.

= Transactions =

The datastore has a lot of odd concepts designed to facilitate building a JTA interface - thread local transactions, implicit transaction management policies, and methods that behave differently whether you pass them a transaction or not.  Forget all that.  Here's what you need to know:

== Entity Groups ==

When you put() your entity, it gets stored somewhere in a gigantic farm of thousands of machines.  In order to perform an atomic transaction, the datastore (currently) requires that all the data that is a part of that transaction live on the same server.  To give you some control over where your data is stored, the datastore has the concept of an *entity group*.

Remember the _parent_ that is part of a {{{Key}}}?  If an entity has a parent, it belongs to the same entity group as its parent.  If an entity does not have a parent, it is the "root" of an entity group.

Within a transaction, you can only access data from a single entity group.  If you try to access data from multiple entity groups, you will get an Exception.  This means you must pick your entity groups carefully, usually to correspond to the data associated with a single user.  Yes, this is as limiting as it sounds.

Why not store all your data with a common parent, putting it all in a single entity group?  You can, but it's a bad idea.  Google limits the number of requests per second that can be served by a particular entity group.

It should be worth mentioning that the term _parent_ is somewhat misleading.  There is no "cascading delete" in the datastore; if you delete the parent entity it will NOT delete the child entities.  You can create child entites with a parent {{{Key}}} (or any other key as a member field) that points to a nonexistant entity.  Parent is only important in that it defines entity groups; if you do not need transactions across several entities, you may wish to use a normal Key relationship - even if the entities have a conceptual parent-child relationship.

== Executing Transactions ==

When you execute a {{{get()}}}, {{{put()}}}, {{{delete()}}}, or {{{prepare(Query)}}}, you will either be in a [http://code.google.com/appengine/docs/java/datastore/transactions.html transaction] or you will not.

If you execute within a transaction:
  * All operations will either succeed completely or fail completely.
  * If another process modifies the your data before you commit, your datastore operations will fail with a {{{ConcurrentModificationException}}}

If you execute without a transaction:
  * All individual datastore operations are treated separately.
  * If there is contention, operations will be automatically retried until the operation succeeds or the system gives up.

= Indexes =

There is a lot of documentation online describing multi-property indexes and how you configure them in your {{{datastore-indexes.xml}}}. Take a look at the [http://code.google.com/appengine/articles/storage_breakdown.html How Entities and Indexes are Stored] and then later into [http://code.google.com/appengine/articles/index_building.html Index Building] if you feel the need.

The datastore has the option of storing each and every (single) property as "indexed" or "unindexed" ({{{Entity.setProperty()}}} vs {{{Entity.setUnindexedProperty()}}}.  Indexes are necessary to perform a query on the relevant property. If you don't index, say, the licensePlate of a Vehicle, you won't be able to query for it. Queries are limited to only one index. This means that if you want to query more than one property in your filters you will need to create an explicit multi-property index including those properties.

To protect you from making a mistake that could be hard to fix (requiring that you re-put() your entire dataset), both JDO and Objectify default to setting all properties as indexed (see [http://code.google.com/appengine/articles/storage_breakdown.html How Entities and Indexes are Stored] for more detail).  This will entail a certain amount of extra overhead maintaining the index on the server.  If you know you will never query by a property, you will want to flag fields as unindexed. Don't worry, be happy, Objectify provides a way to easily flag fields by using annotations.

-----

Now that you are familiar with the underlying concepts of the datastore, read the IntroductionToObjectify.