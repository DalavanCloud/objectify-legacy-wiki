#summary Advanced Patterns in Objectify


<wiki:toc max_depth="3" />

= Suggested (Advanced) Patterns =

These patterns are possible, but are probably specialized and should be used with care.

== Ancestor Queries ==

Using {{{@Parent}}} for advanced queries can save you from creating custom indexes which might otherwise be required. Take this example when you might want to get blog entries since some date. 

{{{
@Unidexed
class Blog {
  @Id Long id;
  String description;
  List<User> contributers;
}

@Unindexed
class BlogEntry {
  @Parent Key<Blog> blog;
  @Id Long id;
  String title;
  String body;
  @Indexed Date dateCreated = new Date();
  @Indexed Date dateUpdated = new Date();
}
}}}

I have a helper which I use that looks like this:

{{{
public static <T,V> QueryResultIterable<T> getChildren(V parent, Class<T> clazz, String filt, Object val){
  if(parent == null) throw new IllegalArgumentException();
  return begin().query(clazz).ancestor(getKey(parent)).filter(filt, val).fetch();
}
}}}

So when I want to get all the blog entries, for a certain blog, since some date, I can write this:

{{{
Date since = ...;
Blog blog = ...;
Iterable<BlogEntry> blogEntries = getChildren(blog, BlogEntry.class, "dateCreated >", since);
}}}

If this was defined without the {{{@Parent}}} it would have required a custom index (on dateCreated and blog). This index would be costly in terms of storage and performance (both on the write, and the read). It also means I can just as easily get all the updated blog entries by blog without creating another index. Any single indexed property on {{{BlogEntry}}} is now available for any blog.

== {{{@PrePersist}}} ==

There are many reasons to use {{{@PrePersist}}} on an entity.

=== Last Updated ===

Using the example above, it might makes sense to update the timestamp whenever a {{{BlogEnty}}} is updated:

{{{
@Unindexed
class BlogEntry {
  ...
  
  @PrePersist
  private void PrePersist() {
    dateUpdated = new Date();
  }
}

}}}

=== Revision History ===

This is a very simple examaple, but it shows the flexibility of using {{{@PrePersist}}}.

{{{
@Unindexed
class BlogEntry {
  ...
  List<String> editHistory = new ArrayList<String>();
  @Transient
  User editor;

  @PrePersist
  private void PrePersist() {
    dateUpdated = new Date();
    if (editor != null) editHistory.add("Edited by " + editor.getName() + " on " + dateUpdated);
  }
}

}}}