#summary API design for Objectify 4.0

= What's wrong with the old API? =
  * Putting Key<?> in the data model is a PITA sometimes
    * Hard to create tidy data models for jsonification or serialization to clients; tends to require ugly @Transient fields
    * Manually populating @Transient fields is errorprone and can be inefficient
  * Asynchrony shoehorned in
    * Most operations already have interfaces that can hide asynchrony, for example:
      * {{{Map<Key<Thing>, Thing> map = ofy.get(k1, k2)}}} can be async
      * {{{Result<Map<Key<Thing>, Thing>> map = ofy.async().get(k1, k2)}}} is unnecessary
  * As get() methods for refs and unfetched entities added, API on Objectify is exploding
  * Reliance on JPA annotations is problem for some
  * Defaulting fields to indexed was a bad idea

= Design goals =
  * Make Key<?> optional in the data model
  * Automatic fetching of object graphs
    * Fine tuning with easy-to-use fetch groups (not JDO fetch groups!)
  * Use interfaces to hide asynchrony from client
    * *Everything* should be asynchronous!
  * Use Ref<?> when asynchrony cannot be hidden (ie, returning concrete classes)
  * Consistent interface for batch get vs filtering
  * All core config/command objects are immutable
  * Fix poor initial design decisions

= Cleanup =
  * Stop using JPA annotations
  * Convert all annotations to imperative form (eg @Index instead of @Indexed)
  * All fields default to not indexed
  * Use builder pattern for ObjectifyOpts
  * Session cache enabled by default
  * More control of Objectify instance; switch read consistency, disable/enable caches, etc
    * Objectify instance remains immutable, however
      * Well not exactly, because the session cache is shared among an instance chain

= Example of class with fetching =
{{{
class Beastie {
   @Fetch @Parent ParentThing parent;
   @Id Long id;

   @Fetch({"bigGroup", "smallGroup"}) SomeThing some;
   @Fetch("bigGroup") List<OtherThing> others;
   @Fetch Ref<OtherThing> refToOtherThing;
   Ref<OtherThing> anotherRef;  // this one is never fetched automatically
}
}}}

= The Ref class =
{{{
class Ref<T> {
    Key<T> getKey();
    T get();
    T getSafe() throws NotFoundException;
}
}}}

= API examples =
{{{
// Simple fetch of refs
ofy.find().refs(ref1, ref2);	// void

// Simple key fetch, always async
Ref<Thing> th = ofy.find().key(thingKey);
Thing th =      ofy.find().key(thingKey).get();
Thing th =      ofy.find().key(thingKey).getSafe();	// throws NotFoundException

// With a fetch group
Thing th = ofy.find().fetch("group").key(thingKey).get();

// Multi get is async, hides asynchrony behind Map interface
Map<Key<Thing>, Thing> ths = ofy.find().keys(123L, 456L);

// Fetching by id
Ref<Thing> th = ofy.find().type(Thing.class).id(123L);
Thing th =      ofy.find().type(Thing.class).id(123L).get();

// With a parent
Ref<Thing> th = ofy.find().type(Thing.class).parent(par).id(123L);

// Batch get, asynchrony is hidden behind Map
Map<Key<Thing>, Thing> ths = ofy.find().type(Thing.class).ids(123L, 456L);

// Queries (asynchrony hidden of course)
Iterable<Key<Thing>> ths =  ofy.find().type(Thing.class).filter("foo", foo).keys();
Iterable<Thing> ths =       ofy.find().type(Thing.class).filter("foo", foo).entities();

// Get first item
Ref<Key<Thing>> th = ofy.find().type(Thing.class).filter("foo", foo).key();
Key<Thing> th =      ofy.find().type(Thing.class).filter("foo", foo).key().get();
Key<Thing> th =      ofy.find().type(Thing.class).filter("foo", foo).key().getSafe();	// throws NotFoundException

Ref<Thing> th = ofy.find().type(Thing.class).filter("foo", foo).entity();
Thing th =      ofy.find().type(Thing.class).filter("foo", foo).entity().get();
Thing th =      ofy.find().type(Thing.class).filter("foo", foo).entity().getSafe();	// throws NotFoundException

// Query with fetch group
Iterable<Thing> ths = ofy.find().fetch("group").type(Thing.class).filter("foo", foo).entities();

// Put
ofy.put().entities(e1, e2, e3);		// asynchronous
ofy.put().entities(e1, e2, e3).now();	// synchronous

// Delete
ofy.delete().entities(e1, e2, e3);		// asynchronous
ofy.delete().entities(e1, e2, e3).now();	// synchronous
}}}