#summary Beginner's guide to Objectify-Appengine
#labels Featured

If you haven't read the [Concepts] yet, please do so first.

<wiki:toc max_depth="2" />

This will explain how to use Objectify to get, put, delete, and query data.  You may find it helpful to open the [needtoaddurl Objectify javadocs] while reading.  These examples omit getter and setter methods for clarity.

= Create Your Entity Classes =

The first step is to define your entity class(es).  Here is an example of a Car:

{{{
@Entity
public class Car
{
	@Id Long id;
	String vin;
	@Unindexed String color;
	@Transient String doNotPersist;

	public Car() {}
	
	public Car(String vin, long color)
	{
		this.vin = vin;
		this.color = color;
	}
}
}}}

Things to note:

  * The class must be annotated with {{{javax.persistence.Entity}}}.

  * Objectify persists fields and fields only.  It does not arbitrarily map fields to the datastore; if you want to change the way a field is stored... rename the field.

 * Objectify will not persist {{{transient}}} fields, {{{static}}} fields, or fields annotated with {{{javax.persistence.Transient}}}.

  * One field must be annotated with {{{javax.persistence.Id}}}.  It can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and put() an object with a null id, a value will be generated for you.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

 * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], or collections of the core value types.

  * There must be a no-arg *public* constructor.

  * For fields that will never be queried against, use @Unindexed to reduce the cost of building indexes.

More information can be found in the AnnotationReference.

= Registering Your Classes =

Before you perform any datastore operations, you must register all your entity classes with the {{{ObjectifyFactory}}}.

{{{
ObjectifyFactory.register(Car.class);
ObjectifyFactory.register(Motorcycle.class);
}}}

Objectify does not scan your classpath for {{{@Entity}}} classes.  It would be trivial to add this feature, but it would require additional jar dependencies (for scannotation or reflections) and a registered startup servlet context listener.  It's easier to just register the classes by hand.

If you want autoregistration anyways, file an enhancement request - if there is enough demand, it will be implemented.

= Basic Operations: Get, Put, Delete =

You can obtain an [addurltojavadocs Objectify] interface from the {{{ObjectifyFactory}}}:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Simple create
Car porche = new Car("2FAST", "red");
ofy.put(porche);
assert porche.id != null;	// id was autogenerated

// Get it back
Car fetched1 = ofy.get(ObjectifyFactory.createKey(Car.class, porche.id));
Car fetched2 = ofy.get(Car.class, porche.id);	// equivalent, more convenient
assert areEqual(porche, fetched1, fetched2);

// Change some data and write it
porche.color = "blue";
ofy.put(porche);

// Delete it
ofy.delete(porche);
}}}

The interface supports batch operations:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Create
Car porche = new Car("2FAST", "red");
Car unimog = new Car("2SLOW", "green");
Car tesla = new Car("2NEW", "blue");
ofy.put(porche, unimog, tesla);	// varargs; Car[] and Iterable<Car> also work

// Get the data back
Map<Key, Car> fetched1 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));

// More convenient shorthand
Map<Key, Car> fetched2 = ofy.get(Car.class, new Long[] { porche.id, unimog.id, tesla.id });

// This works too
Map<Key, Car> fetched3 = ofy.get(Car.class, Arrays.asList(porche.id, unimog.id, tesla.id));

// Batch operations need not be homogenous:
Map<Key, Vehicle> fetched4 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Motorcycle.class, ktm.id));

// Delete the data
ofy.delete(fetched1.values());

// You can delete by key without loading the objects
ofy.delete(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));
}}}

= Querying =

Here are some examples of using queries.  Note that the {{{Query}}} class is the exact same class found in the Datastore API.

{{{
Objectify ofy = ObjectifyFactory.begin();

Query q = ObjectifyFactory.createQuery(Car.class);
q.addfilter("vin", Query.FilterOperator.EQUAL, "123456789");
Car car = ofy.prepare(q).asSingle();

Query q2 = ObjectifyFactory.createQuery(Car.class);
q2.addfilter("vin", Query.FilterOperator.GREATER_THAN, "123456789");
for (Car car: ofy.prepare(q2).asIterable()) {
	System.out.println(car.toString());
}

// You can query for just keys, which will return Key objects much more efficiently than fetching whole objects
Query q3 = ObjectifyFactory.createQuery(Car.class);
q3.setKeysOnly();
Iterable<Key> allKeys = ofy.prepare(q3).asIterable();

// Useful for deleting items
ofy.delete(allKeys);
}}}

= Relationships =

A relationship is simply a {{{Key}}} stored as a field in an entity.  Objectify does not provide "managed" relationships in the way that JDO or JPA does; this is both a blessing and a curse.

There are fundamentally three different kinds of relationships in Objectify:

== Parent Relationship ==

An entity can have a single {{{Key}}} field annotated with {{{@Parent}}}:

{{{
public class Person
{
	@Id Long id;
	String name;
}

@Entity
public class Car
{
	@Id Long id;
	@Parent Key owner;
	String color;
}
}}}

Each Car entity is part of the parent owner's entity group and both can be accessed within a single transaction.  When loading the child entity, the parent {{{Key}}} must be used to generate the child's key:

{{{
Objectify ofy = ObjectifyFactory.begin();

Key owner = ObjectifyFactory.createKey(Person.class, somePersonId);
Car someCar = ofy.get(ObjectifyFactory.createKey(owner, Car.class, someCarId));
}}}

Note that this is an inappropriate use of the @Parent entity; if a car were to be sold to a new owner, you would need to delete the Car and create a new one.  It is often better to use Single Value Relationships even when there is a conceptual parent-child or owner-object relationship; in that case you could simply change the parent.

*If you get() an entity, change the @Parent key field, and put() the entity, you will create a new entity*.  The old entity (with the old parent) will still exist.  You cannot simply change the value of a @Parent key field.

== Single-Value Relationship ==

In Objectify (and the underlying datastore), Keys are just properties like any other value.  Whether it defines a one-to-one relationship or a many-to-one relationship is up to you.  Furthermore, a {{{Key}}} field could refer to any type of entity class.

=== One To One ===

The simplest type of single-value relationship is one-to-one.

{{{
public class Person
{
	@Id 	String name;
	Key significantOther;
}

Objectify ofy = ObjectifyFactory.begin();
Person bob = ofy.get(Person, "bob");
Person bobswife = ofy.get(bob.significantOther);
}}}

Note that Bob's significantOther need not be a Person!

=== Many To One ===

A {{{Key}}} field can represent a many-to-one relationship.

{{{
public class Employee
{
	@Id 	String name;
	Key manager;
}

Objectify ofy = ObjectifyFactory.begin();
Employee bob = ofy.get(Employee, "bob");
Employee fred = ofy.get(bob.manager);
}}}

It looks identical to the one-to-one relationship because it is.  The only difference is a conceptual one.  What if you want to know all the employees managed by Fred?  You use a query.

{{{
Objectify ofy = ObjectifyFactory.begin();

Key fredKey = ObjectifyFactory.createKey(Employee.class, "fred");
Query q = ObjectifyFactory.createQuery(Employee.class);
q.addFilter("manager", FilterOperator.EQUAL, fredKey);
ObjPreparedQuery<Employee> pq = ofy.prepare(q);
Iterable<Employee> subordinates = pq.asIterable();   // or asList()
}}}

If that seems a lot to type, you can wrap it in a convenience method:

{{{
public class Employee
{
	@Id 	String name;
	Key manager;

	public Iterable<Employee> getSubordinates()
	{
		Query q = ObjectifyFactory.createQuery(Employee.class);
		q.addFilter("manager", FilterOperator.EQUAL, ObjectifyFactory.createKey(this));
		ObjPreparedQuery<Employee> pq = ofy.prepare(q);
		return = pq.asIterable();
	}
}
}}}

== Multi-Value Relationship ==

= Transactions =

= Multi-Property Indexes =

= Migrating Schemas =