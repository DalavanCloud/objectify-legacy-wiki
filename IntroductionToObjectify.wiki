#summary Beginner's guide to Objectify-Appengine

This is a combined introduction to Objectify and to the Appengine datastore.

= Concepts =

So, you want to persist some data.  You've probably looked at the [http://code.google.com/appengine/docs/java/datastore/overview.html datastore documentation] and thought "crap, that's complicated!"  Entities, query languages, fetch groups, detaching, transactions... hell those things have bloody _lifecycles_!

This document will talk a lot about entities.  An _entity_ is an object's worth of data in the datastore.  Using Objectify, an entity will correspond to a single POJO class you define.  In the datastore, an entity is a HashMap-like object of type Entity.  Conceptually, they are the same.

== Operations ==

The complexity of JDO is hiding a lot of simplicity under the covers.  There are only four basic operations in the datastore, and any persistence API must boil operations down to:

  * *get()* an entity whole from the datastore.  You can get many at a time.
  * *put()* an entity whole in the datastore.  You can store many at a time.
  * *delete()* an entity from the datastore.  (You guessed it) You can delete many at a time.
  * *prepare()* a Query, which searches the datastore for entities matching criteria you define.

== Keys ==

All entities have either a Long *id* or a String *name*, but those values are not unique by themselves.  In the datastore, entities are identified by the id (or name) and a *kind*, which corresponds to the type of object you are storing.  So, to get Car #959 from the datastore, you need to call something equivalent to {{{get_from_datastore("Car", 959)}}} (not real code yet).

By the way, I lied.  There is actually a third value which is necessary to uniquely identify an entity, called *parent*.  Parent defines a special kind of relationship, placing the child in the same [http://code.google.com/appengine/docs/python/datastore/keysandentitygroups.html entity group] as the parent.  Entity groups will be discussed next in the section on Transactions, but for now what you need to know is that this parent (which is often simply null) is also required to uniquely identify an entity.  So, to get Car #959 from the datastore, you actually need to call something equivalent to {{{get_from_datastore("Car", 959, null)}}} or {{{get_from_datastore("Car", 959, myPrivateCollection)}}}.  Yeech.

Instead of passing three parameters around all the time, the datastore wraps these values into a single object - a _Key_.  That's all a Key is, a holder for the three parts that uniquely identify an entity.  You can create them like this:

{{{
Key rootKey = ObjectifyFactory.createKey(Car.class, 959);
Key keyWithParent = ObjectifyFactory.createKey(parent, Car.class, 959);
}}}

With a Key you can use the most fundamental method on the {{{Objectify}}} interface, nearly identical to the {{{DatastoreService}}} equivalent:

{{{
<T> T get(Key key) throws EntityNotFoundException;
}}}

In Objectify, you define your object as a Java class with a mandatory identifier (Long, long, or String) and an optional parent.  However, when you lookup or reference your object, you do so by _Key_.  In fact, you can (and should) batch together a variety of requests into a single call, even if it will fetch many different kinds of objects:

{{{
Map<Key, Object> lotsOfThings = objectify.get(carKey, airplaneKey, chairKey, personKey, yourMamaKey);
}}}

Actually, I lied again.  We don't force you to create keys by hand all the time.  There is a convenient shorthand for the very common case of loading a single type of object, but don't forget that this is really just creating a {{{Key}}} and calling get()!

{{{
Car c = objectify.get(Car.class, 959);
Map<Key, Car> cars = objectify.get(Car.class, 959, 911, 944, 924);
}}}

By the way, {{{Key}}} is used for relationship references as well.  Remember that value that defines a parent entity?  The type of this parent is {{{Key}}}:

{{{
	public static Key createKey(Key parent, Class<?> kind, long id) {...}
}}}

When you create relationships to other entities in your system, the type of the entity relationship should be Key.

== Transactions ==