#summary Beginner's guide to Objectify-Appengine
#labels Featured

*This documentation reflects the 2.0 beta 1 release of Objectify, which is recommended for use.*

If you haven't read the [Concepts] yet, please do so first.

<wiki:toc max_depth="2" />

This will explain how to use Objectify to get, put, delete, and query data.  You may find it helpful to open the [http://objectify-appengine.googlecode.com/svn/trunk/javadoc/index.html Objectify javadocs] while reading.  These examples omit getter and setter methods for clarity.

= Create Your Entity Classes =

The first step is to define your entity class(es).  Here is an example of a Car:

{{{
public class Car
{
    @Id Long id;
    String vin;
    @Unindexed String color;
    @Transient String doNotPersist;

    private Car() {}
    
    public Car(String vin, long color)
    {
        this.vin = vin;
        this.color = color;
    }
}
}}}

Things to note:

  * Objectify persists fields and fields only.  It does not arbitrarily map fields to the datastore; if you want to change the way a field is stored... rename the field.

 * Objectify will not persist {{{static}}} fields, {{{final}}} fields, or fields annotated with {{{javax.persistence.Transient}}} (it will persist fields with the {{{transient}}} keyword).

  * One field must be annotated with {{{javax.persistence.Id}}}.  It can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and put() an object with a null id, a value will be generated for you.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

  * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], Collections (ie Lists and Sets) of the core value types, or arrays of the core value types.  You can also persist properties of type {{{Key}}}.

  * There must be a no-arg constructor.  It can be private.

  * For fields that will never be queried against, use @Unindexed to reduce the cost of building indexes.

More information can be found in the AnnotationReference.

= Registering Your Classes =

Before you perform any datastore operations, you must register all your entity classes with the {{{ObjectifyService}}}.

{{{
ObjectifyService.register(Car.class);
ObjectifyService.register(Motorcycle.class);
}}}

Objectify does not scan your classpath for {{{@Entity}}} classes.  There are good reasons for and against this - see the  discussion in BestPractices.

= Basic Operations: Get, Put, Delete =

You can obtain an {{{Objectify}}} interface from the {{{ObjectifyService}}}:

{{{
Objectify ofy = ObjectifyService.begin();

// Simple create
Car porche = new Car("2FAST", "red");
ofy.put(porche);
assert porche.id != null;    // id was autogenerated

// Get it back
Car fetched1 = ofy.get(new Key<Car>(Car.class, porche.id));
Car fetched2 = ofy.get(Car.class, porche.id);    // equivalent, more convenient
assert areEqual(porche, fetched1, fetched2);

// Change some data and write it
porche.color = "blue";
ofy.put(porche);

// Delete it
ofy.delete(porche);
}}}

The interface supports batch operations:

{{{
Objectify ofy = ObjectifyService.begin();

// Create
Car porche = new Car("2FAST", "red");
Car unimog = new Car("2SLOW", "green");
Car tesla = new Car("2NEW", "blue");
ofy.put(porche, unimog, tesla);    // varargs; Car[] and Iterable<Car> also work

// Get the data back
Map<Key<Car>, Car> fetched1 = ofy.get(
    new Key<Car>(Car.class, porche.id),
    new Key<Car>(Car.class, unimog.id),
    new Key<Car>(Car.class, tesla.id));

// More convenient shorthand
Map<Key<Car>, Car> fetched2 = ofy.get(Car.class, new Long[] { porche.id, unimog.id, tesla.id });

// This works too
Map<Key<Car>, Car> fetched3 = ofy.get(Car.class, Arrays.asList(porche.id, unimog.id, tesla.id));

// Batch operations need not be homogenous:
Map<Key<Vehicle>, Vehicle> fetched4 = ofy.get(
    new Key<Car>(Car.class, porche.id),
    new Key<Motorcycle>(Motorcycle.class, ktm.id));

// Delete the data
ofy.delete(fetched1.values());

// You can delete by key without loading the objects
ofy.delete(
    new Key<Car>(Car.class, porche.id),
    new Key<Car>(Car.class, unimog.id),
    new Key<Car>(Car.class, tesla.id));
}}}

= Querying =

Here are some examples of using queries.  Objectify's Query mimics the human-friendly [http://code.google.com/appengine/docs/python/datastore/queryclass.html Query class from GAE/Python] rather than the machine-friendly [http://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Query.html GAE/Java] version.

{{{
Objectify ofy = ObjectifyService.begin();

Car car = ofy.query(Car.class).filter("vin", "123456789").get();

// The Query itself is Iterable
Query<Car> q = ofy.query(Car.class).filter("vin >", "123456789");
for (Car car: q) {
    System.out.println(car.toString());
}

// You can query for just keys, which will return Key objects much more efficiently than fetching whole objects
Iterable<Key<Car>> allKeys = ofy.query(Car.class).fetchKeys();

// Useful for deleting items
ofy.delete(allKeys);
}}}

= Relationships =

A relationship is simply a {{{Key}}} stored as a field in an entity.  Objectify does not provide "managed" relationships in the way that JDO or JPA does; this is both a blessing and a curse.  However, because {{{Key}}}
is a generified class, it carries type information about what it points to.

There are fundamentally three different kinds of relationships in Objectify:

== Parent Relationship ==

An entity can have a single {{{Key}}} field annotated with {{{@Parent}}}:

{{{
public class Person
{
    @Id Long id;
    String name;
}

public class Car
{
    @Id Long id;
    @Parent Key<Person> owner;
    String color;
}
}}}

Each Car entity is part of the parent owner's entity group and both can be accessed within a single transaction.  When loading the child entity, the parent {{{Key}}} must be used to generate the child's key:

{{{
Objectify ofy = ObjectifyService.begin();

Key<Person> owner = new Key<Person>(Person.class, somePersonId);
Car someCar = ofy.get(new Key<Car>(owner, Car.class, someCarId));
}}}

Note that this is an inappropriate use of the @Parent entity; if a car were to be sold to a new owner, you would need to delete the Car and create a new one.  It is often better to use Single Value Relationships even when there is a conceptual parent-child or owner-object relationship; in that case you could simply change the parent.

*If you get() an entity, change the @Parent key field, and put() the entity, you will create a new entity*.  The old entity (with the old parent) will still exist.  You cannot simply change the value of a @Parent key field.  This is a fundamental aspect of the appengine datastore; @Parent values form part of an entity's identity.

== Single-Value Relationship ==

In Objectify (and the underlying datastore), Keys are just properties like any other value.  Whether it defines a one-to-one relationship or a many-to-one relationship is up to you.  Furthermore, a {{{Key}}} field could refer to any type of entity class.

=== One To One ===

The simplest type of single-value relationship is one-to-one.

{{{
public class Person
{
    @Id String name;
    Key<Person> significantOther;
}

Objectify ofy = ObjectifyService.begin();
Person bob = ofy.get(Person, "bob");
Person bobswife = ofy.get(bob.significantOther);
}}}

=== Many To One ===

A {{{Key}}} field can represent a many-to-one relationship.

{{{
public class Employee
{
    @Id String name;
    Key<Employee> manager;
}

Objectify ofy = ObjectifyService.begin();
Employee bob = ofy.get(Employee.class, "bob");
Employee fred = ofy.get(bob.manager);
}}}

It looks identical to the one-to-one relationship because it is.  The only difference is a conceptual one.  What if you want to know all the employees managed by Fred?  You use a query.

{{{
Objectify ofy = ObjectifyService.begin();

Iterable<Employee> subordinates = ofy.query(Employee.class).filter("manager", fred);
}}}

== Multi-Value Relationship ==

The datastore can persist simple object types (Long, String, etc) and collections of simple object types.  It can also persist collections (and arrays) of {{{Keys}}}.  This creates an alternative approach for defining one-to-many (and many-to-many) relationships.

{{{
public class Employee
{
    @Id String name;
    Key<Employee>[] subordinates;
}
}}}

This is sometimes useful, but should be used with caution for two reasons:

  # Every time you {{{get()}}} and {{{put()}}} an object, it will fetch and store the entire list of subordinate keys.  If you have large numbers of subordinates, this could become a performance problem.
  # Appengine limits you to 5,000 entries.
  # Because appengine creates an index entry for every value in the collection, you can suffer from [http://code.google.com/appengine/docs/python/datastore/queriesandindexes.html#Big_Entities_and_Exploding_Indexes Exploding Indexes].

Because appengine stores an index entry for each value in the collection, it is possible to issue queries like this:

{{{
Objectify ofy = ObjectifyService.begin();

// should contain Fred
Iterable<Employee> managers = ofy.query(Employee.class).filter("subordinates", bob);
}}}

The decision to use a Multi-Value Relationship will depend heavily upon the shape of your data and the queries you intend to perform.

= Transactions =

Working with transactions is almost the same as working with Objectify normally.

{{{
Objectify ofy = ObjectifyService.beginTransaction();  // instead of begin()
try
{
    ClubMembers cm = ofy.get(ClubMembers.class, "k123");
    cm.incrementByOne();
    ofy.put(cm);

    ofy.getTxn().commit();
}
finally
{
    if (ofy.getTxn().isActive())
        ofy.getTxn().rollback();
}
}}}

All data manipulation methods are the same as you would normally use.

Since entities in Objectify really are Plain Old Java Objects and transactions are tied to the Objectify object, it's easy to work with data inside and outside of transactions (or multiple transactions running in parallel!):

{{{
Objectify ofyNoTxn = ObjectifyService.begin();
Objectify ofyTxn = ObjectifyService.beginTransaction();
try
{
    Foo f = ofyTxn.get(Foo.class, "k123");
    Bar b = ofyNoTxn.get(f.barKey);

    if (b.wantsUp())
        f.increment();
    else
        f.decrement();

    ofyTxn.put(f);

    ofyTxn.getTxn().commit();
}
finally
{
    if (ofyTxn.getTxn().isActive())
        ofyTxn.getTxn().rollback();
}
}}}

You can interleave multiple transactions or nontransactional actions as long as you obey the the cardinal rule:  Within a single transaction (defined by an Objectify object created with beginTransaction()), you may only read or write from a single entity group.

Yes, this means you can get() objects from a transactional Objectify and put() to a nontrasactional Objectify. 

= Multi-Property Indexes =

Multi-property indexes are configured normally in {{{appengine-datastore.xml}}}.  See the regular appengine documentation.

= Migrating Schemas =

Objectify has a very simple facility to help you with basic schema changes.  Let's say you start with a simple entity like this:

{{{
@Entity
public class Person
{
    @Id Long id;
    String name;
}
}}}

Now let's say you're doing some refactoring and you want to rename the field "name" to "fullName".  You can!

{{{
@Entity
public class Person
{
    @Id Long id;
    @OldName("name") String fullName;
}
}}}

When a Person is get()ed, the {{{fullName}}} field will be loaded either the value of _fullName_ or _name_.  If both fields exist, an IllegalStateException will be thrown.  When put(), only _fullName_ will be written.

You can let your application run, slowly replacing all the Person instances, and set up a batch job to replace all legacy instances at your leisure.

Caveat:  Queries do not know about the rename; if you filter by "fullName", you will only get entities that have been converted.

Now that you've migrated all of your data to the new Person format, let's say you now want to store separate first and last names instead of a single fullName field.  Objectify can help:

{{{
public class Person
{
    @Id Long id;
    String firstName;
    String lastName;

    void importCruft(@OldName("fullName") String full)
    {
        String[] names = full.split(" ");
        this.firstName = names[0];
        this.lastName = names[1];
    }
}
}}}

You can specify {{{@OldName}}} on the parameter of any method that takes a single parameter.  The parameter must be type-appropriate for what is in the datastore; you can pass Object and use reflection if you aren't sure.  Process the data in whatever way you see fit.  When the entity is put() again, it will only have _firstName_ and _lastName_.

Caution:  Objectify has no way of knowing that the importCruft() method has loaded the firstName and lastName fields.  If both fullName and firstName/lastName exist in the datastore, the results are undefined.

= @Embedded =

New in 2.0, Objectify supports embedded classes and collections of embedded classes.  This allows you to store structured data within a single POJO entity in a way that that remains queryable.  With a few limitations, this can be an excellent replacement for storing JSON data.

== Embedded Classes ==

You can nest objects to any arbitrary level.

{{{
class LevelTwo {
    String bar;
}

class LevelOne {
    String foo;
    @Unindexed @Embedded LevelTwo two
}

class EntityWithEmbedded {
    @Id Long id;
    @Embedded LevelOne one;
}
}}}

As with normal properties, all values are indexed by default.  You can place @Unindexed on any @Embedded field and all the decendant fields will be @Unindexed.

== Embedded Collections and Arrays ==

You can use @Embedded on collections or arrays:

{{{
class EntityWithEmbeddedCollection {
    @Id Long id;
    @Embedded List<LevelOne> ones = new ArrayList<LevelOne>();
}
}}}

Some things to keep in mind:

  # An @Embedded array/collection cannot be nested inside of another @Embedded array/collection.  It can, however, be nested inside any number of @Embedded classes.
  # You should initialize collections.  Null or empty collections are not written to the datastore and therefore get ignored during load.  Furthermore, the concrete instance will be used as-is, allowing you to initialize collections with Comparators or other state.

== Querying ==

For any indexed field, you can query like this:

{{{
Objectify ofy = ObjectifyService.begin();
ofy.query(EntityWithEmbedded.class).filter("one.two.bar =", "findthis");
}}}

Filtering works for embedded collections just as it does for normal collections.

== Entity Representation ==

You may wish to know how @Embedded fields are persisted so that you an access them through the Low-Level API.  Here is an example:

{{{
EntityWithEmbedded ent = new EntityWithEmbedded();
ent.one = new LevelOne();
ent.one.foo = "Foo Value";
ent.one.two = new LevelTwo();
ent.one.two.bar = "Bar Value";

Objectify ofy = ObjectifyService.begin();
ofy.put(ent);
}}}

This will produce an entity that contains:

|| one.foo || "Foo Value" ||
|| one.two.bar || "Bar Value" ||

You can see why query filters work the way they do.

For @Embedded collections and arrays, the storage mechanism is more complicated:

{{{
EntityWithEmbeddedCollection ent = new EntityWithEmbeddedCollection();
for (int i=1; i<=4; i++) {
    LevelOne one = new LevelOne();
    one.foo = "foo" + i;
    one.two = new LevelTwo();
    one.two.bar = "bar" + i;

    ent.ones.add(one);
}

Objectify ofy = ObjectifyService.begin();
ofy.put(ent);
}}}

This will produce an entity that contains:

|| ones.foo || {{{ ["foo1", "foo2", "foo3", "foo4"] }}} ||
|| ones.two.bar || {{{ ["bar1", "bar2", "bar3", "bar4"] }}} ||

This is what the entity would look like if the second and third values in the {{{ones}}} collection were {{{null}}}:

|| ones.foo^null || {{{ [1, 2] }}} ||
|| ones.foo || {{{ ["foo1", "foo4"] }}} ||
|| ones.two.bar || {{{ ["bar1", "bar4"] }}} ||

The synthetic ^null property only exists if the collection contains nulls.

== Schema Migration ==

The {{{@OldName}}} annotation can be used on any field, including {{{@Embedded}}} fields.  For example, this class will safely read in instances previously saved with {{{EntityWithEmbeddedCollection}}}:

{{{
class Together {
    @OldName("foo") String partOne;
    @OldName("two.bar") String partTwo;
}

class NextEntity {
    @Id Long id;
    @OldName("ones") @Embedded List<Together> stuff = new ArrayList<Together>();
}
}}}

{{{@OldName}}} methods work as well, however you cannot use {{{@Embedded}}} on method parameters.

= Caching =

New in 2.0rc1, Objectify integrates the appengine memcache to improve the performance of your application.  Simply annotate your entity class with {{{@Cached}}}:

{{{
@Cached
public class MyEntity {
    @Id Long id;
    ...
}
}}}

That's it!  Objectify will utilize the memcache service to reduce read load on the datastore.

What you should know about caching:

  * This feature is new and should be considered somewhat experimental.  However, all unit tests pass with the cache enabled.
  * The raw data of your entity is cached, not your POJO class.  Your objects will not be serialized.
  * Only get(), put(), and delete() interact with the cache.  query() is not cached.
  * Writes will "write through" the cache to the datastore.  Performance is only improved on read-heavy applications (which, fortunately, most are).
  * Negative results are cached as well as positive results.
  * Transactional reads bypass the cache.  Only successful commits modify the cache.
  * You can define an expiration time for each entity in the annotation: {{{@Cached(expirationSeconds=600)}}}.  By default entities will be cached until memory pressure (or an 'incident' in the datacenter) evicts them.

-----

Now, read the BestPractices.