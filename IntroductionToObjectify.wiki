#summary Beginner's guide to Objectify-Appengine
#labels Featured

If you haven't read the [Concepts] yet, please do so first.

<wiki:toc max_depth="2" />

This will explain how to use Objectify to get, put, delete, and query data.  You may find it helpful to open the [needtoaddurl Objectify javadocs] while reading. We also take advantage of [http://projectlombok.org Project Lombok] in some of our examples to remove the typical Java boilerplate.

= Create Your Entity Classes =

The first step is to define your entity class(es).  Here is an example of a Car, omitting getter and setter methods for clarity:

{{{
@Entity
public class Car
{
	@Id Long id;
	String vin;
	@Unindexed String color;
	@Transient String doNotPersist;

	public Car() {}
	
	public Car(String vin, long color)
	{
		this.vin = vin;
		this.color = color;
	}
}
}}}

Things to note:

  * The class must be annotated with {{{javax.persistence.Entity}}}.

  * Objectify persists fields and fields only.  It is not an arbitrary ORM-type mapping system.  If you want to change the way a field is stored... rename the field.

 * Objectify will not persist {{{transient}}} fields, {{{static}}} fields, or fields annotated with {{{javax.persistence.Transient}}}.

  * One field must be annotated with {{{javax.persistence.Id}}}.  It can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and put() an object with a null id, a value will be generated for you.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

 * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], or collections of the core value types.

  * There must be a no-arg *public* constructor.

  * For fields that will never be queried against, use @Unindexed to reduce server overhead.

== Annotations ==
|| Annotation || Level || Properties || Description || 
|| {{{@Entity}}} || Class || Name == kind name in datastore || This is an entity which will be stored as a certain *kind*. ||
|| {{{@Id}}} || Field || -- || Can only be used once per {{{Class}}}; Must be applied to a field of type {{{String}}} or {{{Long}}}/{{{long}}}. This will represent the id or name of the [Concepts Key], respectively. Only the *{{{Long}}}* type allows *auto-generation* || 
|| {{{@Unindexed}}} || Field || -- || Do not index this property during insertion into the datastore || 
|| {{{@OldName}}} || Field || Name == property to read || The field will be filled in if a value doesn't exist for the property. {{{ @OldName("hair") String hairColor}}}; hairColor = values["hairColor"]; if (hairColor==null) hairColor = values["hair"]  || 
|| {{{@Parent}}} || Field || -- || The (transient) field which represents the Parents {{{Key}}} for an owned object (non-root) once it has been persisted || 

= Registering Your Classes =

Before you perform any datastore operations, you must register all your entity classes with the {{{ObjectifyFactory}}}. It is ok to do this as a static initializer at the top of your entity.

{{{
@Entity
public class Car implements Serializable {
	static {
		ObjectifyFactory.register(Car.class);
	}

	public Car() {}
}
}}}

Objectify does not scan your classpath for {{{@Entity}}} classes.  It would be trivial to add this feature, but it would require additional jar dependencies (for scannotation or reflectivity) and a registered startup servlet context listener.  It's easier to just register the classes by hand.

If you want autoregistration anyways, file an enhancement request - if there is enough demand, it will be implemented.

= Basic Operations: Get, Put, Delete =

You can obtain an [addurltojavadocs Objectify] interface from the {{{ObjectifyFactory}}}:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Simple create
Car porche = new Car("2FAST", "red");
ofy.put(porche);
assert porche.id != null;	// id was autogenerated

// Get it back
Car fetched1 = ofy.get(ObjectifyFactory.createKey(Car.class, porche.id));
Car fetched2 = ofy.get(Car.class, porche.id);	// more convenient
assert areEqual(porche, fetched1, fetched2);

// Change some data and write it
porche.color = "blue";
ofy.put(porche);

// Delete it
ofy.delete(porche);
}}}

The interface supports batch operations:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Create
Car porche = new Car("2FAST", "red");
Car unimog = new Car("2SLOW", "green");
Car tesla = new Car("2NEW", "blue");
ofy.put(porche, unimog, tesla);	// varargs; Car[] and Iterable<Car> also work

// Get the data back
Map<Key, Car> fetched1 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));

// More convenient shorthand
Map<Key, Car> fetched2 = ofy.get(Car.class, new Long[] { porche.id, unimog.id, tesla.id });

// This works too
Map<Key, Car> fetched3 = ofy.get(Car.class, Arrays.asList(porche.id, unimog.id, tesla.id));

// Batch operations need not be homogenous:
Map<Key, Vehicle> fetched4 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Motorcycle.class, ktm.id));

// Delete the data
ofy.delete(fetched1.values());

// You can delete by key without loading the objects
ofy.delete(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));
}}}

= Querying =

Here are some examples of using queries.  Note that the Query class is the same class surfaced in the Datastore API.

{{{
Objectify ofy = ObjectifyFactory.begin();

Query q = ObjectifyFactory.createQuery(Car.class);
q.addfilter("vin", Query.FilterOperator.EQUAL, "123456789");
Car car = ofy.prepare(q).asSingle();

Query q2 = ObjectifyFactory.createQuery(Car.class);
q2.addfilter("vin", Query.FilterOperator.GREATER_THAN, "123456789");
for (Car car: ofy.prepare(q2).asIterable()) {
	System.out.println(car.toString());
}

// You can query for just keys, which will return Key objects much more efficiently than fetching whole objects
Query q3 = ObjectifyFactory.createQuery(Car.class);
q3.setKeysOnly();
Iterable<Key> allKeys = ofy.prepare(q3).asIterable();

// Useful for deleting items
ofy.delete(allKeys);
}}}

= Relationships =

A relationship is simply a {{{Key}}} stored as a field in an entity.  There are fundamentally three different kinds of relationships in Objectify:

== Parent Relationship ==

An entity can have a single {{{Key}}} field annotated with {{{@Parent}}}:

{{{
public class Person {

	@Id Long id;
	String name;
        public Person(){}
}

@Entity
public class Car
{
	@Id Long id;
	@Parent Key owner;
	String color;
        public Car(){}
}
}}}

Each Car entity is part of the parent owner's entity group and both can be accessed within a single transaction.  When loading the child entity, the parent {{{Key}}} must be used to generate the child's key:

{{{
Objectify ofy = ObjectifyFactory.begin();
Person meSomeday = new Person();
meSomeday.name = "super cool-guy";
Key meSomedayKey = ofy.put(meSomeday);

Car newShinyCar = new Car();
newShinyCar.owner = meSomedayKey;
newShinyCar.color = "Shiny RED";
Key nscKey = ofy.put(newShinyCar);
Long someCarId = newShinyCar.id //== nscKey.getId()

Car porche = ofy.get(ObjectifyFactory.createKey(meSomedayKey, Car.class, someCarId));
}}}

== Single-Value Relationship ==

== Multi-Value Relationship ==

Say you have a Player who can have multiple Scores that record each play of a game. Below is an example one way to accomplish that. In this case, we know that a Player will never have more than 1000 Scores (a limit on Datastore queries) so we do not bother with pagination.

If a new Score is created, then you will want to clear the internal cache of Scores within the Player object. This can be done by either getting the Player object from the database again or calling player.setScores(null).

{{{
@Entity
@Data
public class Player implements Serializable
{
	private static final long serialVersionUID = 1L;

	private static Objectify ofy = null;

	static {
		ObjectifyFactory.register(Player.class);
		ofy = ObjectifyFactory.begin();
	}

	@Id private long id;

	@Transient private List<Score> scoresCache;

	/** */
	public Player() {}

	/** */
	public Player(long id)
	{
		this.id = id;
	}

	/** */
	public List<Score> getScores()
	{
		if (this.scoresCache == null)
		{
			Key ancestor = ObjectifyFactory.createKey(this);
			Query q = ObjectifyFactory.createQuery(Score.class).setAncestor(ancestor);
			ObjPreparedQuery<Score> pq = ofy.prepare(q);
			this.scoresCache = pq.asList(withLimit(1000).chunkSize(1000));
		}
		return this.scoresCache;
	}
}

@Entity
@Data
public class Score implements Serializable
{
	private static final long serialVersionUID = 1L;

	static {
		ObjectifyFactory.register(Score.class);
	}

	@Id private Long id;
	@Parent private Key playerKey;
	private int answer;
	private Date createdDate;

	/** */
	public Score() {}

	/** */
	public Score(Player player, int answer)
	{
		this.playerKey = ObjectifyFactory.createKey(player);
		this.answer = answer;

		this.createdDate = new Date();
	}
}
}}}
= Transactions =

= Multi-Property Indexes =

= Migrating Schemas =