#summary Beginner's guide to Objectify-Appengine

If you haven't read the [Concepts] yet, please do so first.

<wiki:toc max_depth="1" />

This will explain how to use Objectify to get, put, delete, and query data.  You may find it helpful to open the [needtoaddurl Objectify javadocs] while reading.

= Create Your Entity Classes =

The first step is to define your entity class(es).  Here is an example of a Car, omitting getter and setter methods for clarity:

{{{
@Entity
public class Car
{
	@Id Long id;
	String vin;
	@Unindexed String color;

	public Car() {}
	
	public Car(String vin, long color)
	{
		this.vin = vin;
		this.color = color;
	}
}
}}}

Things to note:

  * The class must be annotated with {{{javax.persistence.Entity}}}.

  * Objectify persists fields and fields only.  It is not an arbitrary ORM-type mapping system.  If you want to change the way a field is stored... rename the field.

 * Objectify will not persist {{{transient}}} fields, {{{static}}} fields, or fields annotated with {{{javax.persistence.Transient}}}.

  * One field must be annotated with {{{javax.persistence.Id}}}.  It can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and put() an object with a null id, a value will be generated for you.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

 * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], or collections of the core value types.

  * There must be a no-arg *public* constructor.

  * For fields that will never be queried against, use @Unindexed to reduce server overhead.

= Registering Your Classes =

Before you perform any datastore operations, you must (probably in a static initializer) register all your entity classes with the {{{ObjectifyFactory}}}.

{{{
static {
	ObjectifyFactory.register(Car.class);
}
}}}

Objectify does not scan your classpath for {{{@Entity}}} classes.  It would be trivial to add this feature, but it would require additional jar dependencies (for scannotation or reflectivity) and a registered startup servlet context listener.  Unless you have a very large number of entities, it's easier to just register the classes by hand.

If you want autoregistration anyways, file an enhancement request - if there is enough demand, it will be implemented.

= Basic Operations: Get, Put, Delete =

You can obtain an [addurltojavadocs Objectify] interface from the {{{ObjectifyFactory}}}:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Simple create
Car porche = new Car("2FAST", "red");
ofy.put(porche);
assert porche.id != null;	// id was autogenerated

// Get it back
Car fetched1 = ofy.get(ObjectifyFactory.createKey(Car.class, porche.id));
Car fetched2 = ofy.get(Car.class, porche.id);	// more convenient
assert areEqual(porche, fetched1, fetched2);

// Change some data and write it
porche.color = "blue";
ofy.put(porche);

// Delete it
ofy.delete(porche);
}}}

The interface supports batch operations:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Create
Car porche = new Car("2FAST", "red");
Car unimog = new Car("2SLOW", "green");
Car tesla = new Car("2NEW", "blue");
ofy.put(porche, unimog, tesla);	// varargs; Car[] and Iterable<Car> also work

// Get the data back
Map<Key, Car> fetched1 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));

// More convenient shorthand
Map<Key, Car> fetched2 = ofy.get(Car.class, new Long[] { porche.id, unimog.id, tesla.id });

// This works too
Map<Key, Car> fetched3 = ofy.get(Car.class, Arrays.asList(porche.id, unimog.id, tesla.id));

// Batch operations need not be homogenous:
Map<Key, Vehicle> fetched4 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Motorcycle.class, ktm.id));

// Delete the data
ofy.delete(fetched1.values());

// You can delete by key without loading the objects
ofy.delete(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));
}}}

= Querying =

Here are some examples of using queries.  Note that the Query class is the same class surfaced in the Datastore API.

{{{
Objectify ofy = ObjectifyFactory.begin();

Query q = ObjectifyFactory.createQuery(Car.class);
q.addfilter("vin", Query.FilterOperator.EQUAL, "123456789");
Car car = ofy.prepare(q).asSingle();

Query q2 = ObjectifyFactory.createQuery(Car.class);
q2.addfilter("vin", Query.FilterOperator.GREATER_THAN, "123456789");
for (Car car: ofy.prepare(q2).asIterable()) {
	System.out.println(car.toString());
}

// You can query for just keys, which will return Key objects much more efficiently than fetching whole objects
Query q3 = ObjectifyFactory.createQuery(Car.class);
q3.setKeysOnly();
Iterable<Key> allKeys = ofy.prepare(q3).asIterable();

// Useful for deleting items
ofy.delete(allKeys);
}}}

= Relationships =

A relationship is simply a {{{Key}}} stored as a field in an entity.  There are fundamentally three different kinds of relationships in Objectify:

== Parent Relationship ==

An entity can have a single {{{Key}}} field annotated with {{{@Parent}}}:

{{{
@Entity
public class Car
{
	@Id Long id;
	@Parent Key owner;
	String color;
}
}}}

Each Car entity is part of the parent owner's entity group and both can be accessed within a single transaction.  When loading the child entity, the parent {{{Key}}} must be used to generate the child's key:

{{{
Objectify ofy = ObjectifyFactory.begin();
Car porche = ofy.get(ObjectifyFactory.createKey(meSomeday, Car.class, someCarId));
}}}

== Single-Value Relationship ==

== Multi-Value Relationship ==

= Transactions =

= Migrating Schemas =