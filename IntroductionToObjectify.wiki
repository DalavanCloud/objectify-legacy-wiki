#summary Beginner's guide to Objectify-Appengine
#labels Featured

If you haven't read the [Concepts] yet, please do so first.

<wiki:toc max_depth="2" />

This will explain how to use Objectify to get, put, delete, and query data.  You may find it helpful to open the [http://objectify-appengine.googlecode.com/svn/trunk/javadoc/index.html Objectify javadocs] while reading.  These examples omit getter and setter methods for clarity.

= Create Your Entity Classes =

The first step is to define your entity class(es).  Here is an example of a Car:

{{{
@Entity
public class Car
{
	@Id Long id;
	String vin;
	@Unindexed String color;
	@Transient String doNotPersist;

	public Car() {}
	
	public Car(String vin, long color)
	{
		this.vin = vin;
		this.color = color;
	}
}
}}}

Things to note:

  * The class must be annotated with {{{javax.persistence.Entity}}}.

  * Objectify persists fields and fields only.  It does not arbitrarily map fields to the datastore; if you want to change the way a field is stored... rename the field.

 * Objectify will not persist {{{transient}}} fields, {{{static}}} fields, or fields annotated with {{{javax.persistence.Transient}}}.

  * One field must be annotated with {{{javax.persistence.Id}}}.  It can be of type {{{Long}}}, {{{long}}}, or {{{String}}}.  If you use {{{Long}}} and put() an object with a null id, a value will be generated for you.  If you use {{{String}}} or the primitive {{{long}}} type, values will never be autogenerated.

 * You can persist any of the [http://code.google.com/appengine/docs/java/datastore/dataclasses.html#Core_Value_Types core value types], or collections of the core value types.

  * There must be a no-arg *public* constructor.

  * For fields that will never be queried against, use @Unindexed to reduce the cost of building indexes.

More information can be found in the AnnotationReference.

= Registering Your Classes =

Before you perform any datastore operations, you must register all your entity classes with the {{{ObjectifyFactory}}}.

{{{
ObjectifyFactory.register(Car.class);
ObjectifyFactory.register(Motorcycle.class);
}}}

Objectify does not scan your classpath for {{{@Entity}}} classes.  It would be trivial to add this feature, but it would require additional jar dependencies (for scannotation or reflections) and a registered startup servlet context listener.  It's easier to just register the classes by hand.

If you want autoregistration anyways, file an enhancement request - if there is enough demand, it will be implemented.

= Basic Operations: Get, Put, Delete =

You can obtain an {{{Objectify}}} interface from the {{{ObjectifyFactory}}}:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Simple create
Car porche = new Car("2FAST", "red");
ofy.put(porche);
assert porche.id != null;	// id was autogenerated

// Get it back
Car fetched1 = ofy.get(ObjectifyFactory.createKey(Car.class, porche.id));
Car fetched2 = ofy.get(Car.class, porche.id);	// equivalent, more convenient
assert areEqual(porche, fetched1, fetched2);

// Change some data and write it
porche.color = "blue";
ofy.put(porche);

// Delete it
ofy.delete(porche);
}}}

The interface supports batch operations:

{{{
Objectify ofy = ObjectifyFactory.begin();

// Create
Car porche = new Car("2FAST", "red");
Car unimog = new Car("2SLOW", "green");
Car tesla = new Car("2NEW", "blue");
ofy.put(porche, unimog, tesla);	// varargs; Car[] and Iterable<Car> also work

// Get the data back
Map<Key, Car> fetched1 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));

// More convenient shorthand
Map<Key, Car> fetched2 = ofy.get(Car.class, new Long[] { porche.id, unimog.id, tesla.id });

// This works too
Map<Key, Car> fetched3 = ofy.get(Car.class, Arrays.asList(porche.id, unimog.id, tesla.id));

// Batch operations need not be homogenous:
Map<Key, Vehicle> fetched4 = ofy.get(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Motorcycle.class, ktm.id));

// Delete the data
ofy.delete(fetched1.values());

// You can delete by key without loading the objects
ofy.delete(
	ObjectifyFactory.createKey(Car.class, porche.id),
	ObjectifyFactory.createKey(Car.class, unimog.id),
	ObjectifyFactory.createKey(Car.class, tesla.id));
}}}

= Querying =

Here are some examples of using queries.  Note that the {{{Query}}} class is the exact same class found in the Datastore API.

{{{
Objectify ofy = ObjectifyFactory.begin();

Query q = ObjectifyFactory.createQuery(Car.class);
q.addfilter("vin", Query.FilterOperator.EQUAL, "123456789");
Car car = ofy.prepare(q).asSingle();

Query q2 = ObjectifyFactory.createQuery(Car.class);
q2.addfilter("vin", Query.FilterOperator.GREATER_THAN, "123456789");
for (Car car: ofy.prepare(q2).asIterable()) {
	System.out.println(car.toString());
}

// You can query for just keys, which will return Key objects much more efficiently than fetching whole objects
Query q3 = ObjectifyFactory.createQuery(Car.class);
q3.setKeysOnly();
Iterable<Key> allKeys = ofy.prepare(q3).asIterable();

// Useful for deleting items
ofy.delete(allKeys);
}}}

= Relationships =

A relationship is simply a {{{Key}}} stored as a field in an entity.  Objectify does not provide "managed" relationships in the way that JDO or JPA does; this is both a blessing and a curse.

There are fundamentally three different kinds of relationships in Objectify:

== Parent Relationship ==

An entity can have a single {{{Key}}} field annotated with {{{@Parent}}}:

{{{
public class Person
{
	@Id Long id;
	String name;
}

@Entity
public class Car
{
	@Id Long id;
	@Parent Key owner;
	String color;
}
}}}

Each Car entity is part of the parent owner's entity group and both can be accessed within a single transaction.  When loading the child entity, the parent {{{Key}}} must be used to generate the child's key:

{{{
Objectify ofy = ObjectifyFactory.begin();

Key owner = ObjectifyFactory.createKey(Person.class, somePersonId);
Car someCar = ofy.get(ObjectifyFactory.createKey(owner, Car.class, someCarId));
}}}

Note that this is an inappropriate use of the @Parent entity; if a car were to be sold to a new owner, you would need to delete the Car and create a new one.  It is often better to use Single Value Relationships even when there is a conceptual parent-child or owner-object relationship; in that case you could simply change the parent.

*If you get() an entity, change the @Parent key field, and put() the entity, you will create a new entity*.  The old entity (with the old parent) will still exist.  You cannot simply change the value of a @Parent key field.

== Single-Value Relationship ==

In Objectify (and the underlying datastore), Keys are just properties like any other value.  Whether it defines a one-to-one relationship or a many-to-one relationship is up to you.  Furthermore, a {{{Key}}} field could refer to any type of entity class.

=== One To One ===

The simplest type of single-value relationship is one-to-one.

{{{
public class Person
{
	@Id 	String name;
	Key significantOther;
}

Objectify ofy = ObjectifyFactory.begin();
Person bob = ofy.get(Person, "bob");
Person bobswife = ofy.get(bob.significantOther);
}}}

Note that Bob's significantOther need not be a Person!

=== Many To One ===

A {{{Key}}} field can represent a many-to-one relationship.

{{{
public class Employee
{
	@Id 	String name;
	Key manager;
}

Objectify ofy = ObjectifyFactory.begin();
Employee bob = ofy.get(Employee.class, "bob");
Employee fred = ofy.get(bob.manager);
}}}

It looks identical to the one-to-one relationship because it is.  The only difference is a conceptual one.  What if you want to know all the employees managed by Fred?  You use a query.

{{{
Objectify ofy = ObjectifyFactory.begin();

Key fredKey = ObjectifyFactory.createKey(Employee.class, "fred");
Query q = ObjectifyFactory.createQuery(Employee.class);
q.addFilter("manager", FilterOperator.EQUAL, fredKey);
ObjPreparedQuery<Employee> pq = ofy.prepare(q);
Iterable<Employee> subordinates = pq.asIterable();   // or asList()
}}}

If that seems a lot to type, you can wrap it in a convenience method:

{{{
public class Employee
{
	@Id String name;
	Key manager;

	public Iterable<Employee> getSubordinates()
	{
		Objectify ofy = ObjectifyFactory.begin();
		Query q = ObjectifyFactory.createQuery(Employee.class);
		q.addFilter("manager", FilterOperator.EQUAL, ObjectifyFactory.createKey(this));
		ObjPreparedQuery<Employee> pq = ofy.prepare(q);
		return = pq.asIterable();
	}
}
}}}

== Multi-Value Relationship ==

The datastore can persist simple object types (Long, String, etc) and collections of simple object types.  It can also persist collections (and arrays) of Keys.  This creates an alternative approach for defining one-to-many (and many-to-many) relationships.

{{{
public class Employee
{
	@Id String name;
	Key[] subordinates;
}
}}}

This is sometimes useful, but should be used with caution for two reasons:

  # Every time you {{{get()}}} and {{{put()}}} an object, it will fetch and store the entire list of subordinate Keys.  If you have large numbers of subordinates, this could become a performance problem.
  # Because appengine creates an index entry for every value in the collection, you can suffer from [http://code.google.com/appengine/docs/python/datastore/queriesandindexes.html#Big_Entities_and_Exploding_Indexes Exploding Indexes].

Because appengine stores an index entry for each value in the collection, it is possible to issue queries like this:

{{{
Objectify ofy = ObjectifyFactory.begin();

Key bobKey = ObjectifyFactory.createKey(Employee.class, "bob");
Query q = ObjectifyFactory.createQuery(Employee.class);
q.addFilter("subordinates", FilterOperator.EQUAL, bobKey);
ObjPreparedQuery<Employee> pq = ofy.prepare(q);
Iterable<Employee> managers = pq.asIterable();  // should contain Fred
}}}

The decision to use a Multi-Value Relationship will depend heavily upon the shape of your data and the queries you intend to perform.

= Transactions =

Working with transactions is almost the same as working with Objectify normally.

{{{
Objectify ofy = ObjectifyFactory.beginTransaction();  // instead of begin()
try
{
	ClubMembers cm = ofy.get(ClubMembers.class, "k123");
	cm.incrementByOne();
	ofy.put(cm);

	ofy.getTxn().commit();
}
finally
{
	if (ofy.getTxn().isActive())
		ofy.getTxn().rollback();
}
}}}

All data manipulation methods are the same as you would normally use.

Since entities in Objectify really are Plain Old Java Objects and transactions are tied to the Objectify object, it's easy to work with data inside and outside of transactions (or multiple transactions running in parallel!):

{{{
Objectify ofyNoTxn = ObjectifyFactory.begin();
Objectify ofyTxn = ObjectifyFactory.beginTransaction();
try
{
	Foo f = ofyTxn.get(Foo.class, "k123");
	Bar b = ofyNoTxn.get(f.barKey);

	if (b.wantsUp())
		f.increment();
	else
		f.decrement();

	ofyTxn.put(f);

	ofyTxn.getTxn().commit();
}
finally
{
	if (ofy.getTxn().isActive())
		ofy.getTxn().rollback();
}
}}}

You can interleave multiple transactions or nontrasactional actions as long as you obey the the cardinal rule:  Within a single transaction (defined by an Objectify object created with beginTransaction()), you may only read or write from a single entity group.

Yes, this means you can get() objects from a transactional Objectify and put() to a nontrasactional Objectify. 

= Multi-Property Indexes =

Multi-property indexes are configured normally in {{{appengine-datastore.xml}}}.  See the regular appengine documentation.

= Migrating Schemas =

Objectify has a very simple facility to help you with basic schema changes.  Let's say you start with a simple entity like this:

{{{
@Entity
public class Person
{
	@Id Long id;
	String name;
}
}}}

Now let's say you want to add a "nickname" field and you don't like the ambiguity.  You'd like to rename the field "name" to "fullName".  You can!

{{{
@Entity
public class Person
{
	@Id Long id;
	@OldName("name") String fullName;
}
}}}

When a Person is get()ed, the {{{fullName}}} field will be loaded either the value of _fullName_ or _name_.  If both fields exist, an IllegalStateException will be thrown.  When put(), only _fullName_ will be written.

You can let your application run, slowly replacing all the Person instances, and set up a batch job to replace all legacy instances at your leisure.

Now that you've migrated all of your data to the new Person format, let's say you now want to store separate first and last names instead of a single fullName field.  Objectify can help:

{{{
@Entity
public class Person
{
	@Id Long id;
	String firstName;
	String lastName;

	@OldName("fullName")
	void importCruft(String full)
	{
		String[] names = full.split(" ");
		this.firstName = names[0];
		this.lastName = names[1];
	}
}
}}}

You can specify {{{@OldName}}} on a method that takes a single parameter.  The parameter must be a type appropriate for what is in the datastore; you can pass Object and use reflection if you aren't sure.  Process the data in whatever way you see fit.  When the entity is put() again, it will only have _firstName_ and _lastName_.

Caution:  Objectify has no way of knowing that the importCruft() method has loaded the firstName and lastName fields.  If both fullName and firstName/lastName exist in the datastore, the results are undefined.