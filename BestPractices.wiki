#summary Patterns and best practices for using Objectify
#labels Featured

<wiki:toc max_depth="3" />

= Registering Your Entities =

The first question you will have is "when and how should I register my entity classes?"  The obvious answer is to do it at application startup in a servlet context listener or an init servlet - wherever your application starts running.  However, there is an easier way:

== Use a DAO ==

By accessing Objectify through your own DAO class, you can register your entities in a static initializer and also add domain-specific helper methods.  Create a DAO class extending DAOBase:

{{{
public class DAO extends DAOBase
{
    static {
        ObjectifyService.register(YourEntity.class);
        ObjectifyService.register(YourOtherEntity.class);

        ObjectifyService.setDatastoreTimeoutRetryCount(3);
    }

    /** Your DAO can have your own useful methods */
    public MyThing getOrCreateMyThing(long id)
    {
        MyThing found = ofy().find(clazz, id);
        if (found == null)
            return new MyThing(id);
        else
            return found;
    }
}
}}}

Now you can use your DAO and any higher-level, application-specific methods:

{{{
DAO dao = new DAO();

MyThing thing = dao.getOrCreateThing(123);
thing.incrementUseCount();

dao.ofy().put(thing);
}}}

Access the factory by calling {{{dao.fact()}}}.

== How NOT To Register Entities ==

You might think that you could register an entity as a static initializer for the entity class itself:

{{{
public class ThingA
{
    static { ObjectifyService.factory().register(ThingA.class); }
    // ... the rest of the entity definition
}
}}}

This is dangerous!  Because Java loads (and initializes) classes on-demand, Objectify cannot guarantee that your class will be registered at the time that it is fetched from the database.  For example, suppose you execute a query that might return several different kinds of entities:

{{{
OQuery<Object> lotsOfThingsQuery = ObjectifyService.factory().createQuery();
lotsOfThingsQuery.ancestor(someParent);    // could find both ThingA and ThingB entities
Objectify ofy = ObjectifyService.factory().begin();
ofy.prepare(lotsOfThingsQuery).asSingle();    // throws IllegalStateException!
}}}

When Objectify tries to reconstitute an object of type ThingA, it won't be able to because the ThingA class will not yet have been loaded and the static initializer will not have been called.  If your application actually does use a ThingA before this query is executed, it will work - and in fact, it may work 99.99% of the time.  But do you really want to hunt down mysterious IllegalStateExceptions 0.01% of the time?

== Automatic Scanning ==

Most J2EE-style frameworks, including Appengine's JDO/JPA system, do classpath scanning and can automatically register classes that have @Entity or other relevant annotations.  This is convenient and could easily be added to Objectify without changing a single source file.  There are, however, several reasons why this isn't part of the core:

  # This feature requires either [http://scannotation.sourceforge.net/ Scannotations] or [http://code.google.com/p/reflections/ Reflections], bringing in 5-6 dependency jars.  Objectify requires zero dependency jars, and we are loathe to change that.
  # Developers would need to add a startup hook to your web.xml (a ServletContextListener) in order to trigger this scanning.  Objectify currently requires zero changes to web.xml.
  # Classpath scanning is *slow* because it opens each .class and .jar file in your project and processes every single class file with a bytecode manipulator.  For a moderately sized project this easily adds 3-5 seconds to your application initialization time.  That's 3-5 additional seconds that real-world users must sit waiting while your application cold-starts.

Of these issues, the last is the most fatal.  If you think "My application gets a lot of traffic!  I don't need to worry about cold starts!", you are overlooking the fact that App Engine starts and stops instances to meet demand all the time - at least one user somewhere is going to be affected on every spinup.  Plus this happens every time you redeploy your application!  There is no escaping cold-start time.

Furthermore, classpath scanning costs accumulate.  If you use other tools that perform classpath scanning (Weld, Spring, JAX-RS, etc), they each will also spend 3-5s scanning your jars.  It isn't hard to push your cold-start time into the tens of seconds.

That said, 3-5s might be reasonable for your specific project.  It should be very easy to add as your own ServletContextListener that calls Reflections and registers the @Entity classes.  If you want to contribute this code, we would consider adding it as an optional module.

= Interesting discussions related to Objectify =
 * [http://groups.google.com/group/google-appengine-java/browse_thread/thread/4467986eaf01788b/d3a1678a44242c25 Original release  announcement on GAE-Java]
 * [http://www.youtube.com/watch?v=AgaL6NGpkB8 Google I/O 2009 - ..Scalable, Complex Apps on App Engine]
 * [http://groups.google.com/group/google-appengine-java/browse_thread/thread/f20d922ffecb310c Differences between Twig and Objectify plus example of million user fanout]
 * [http://turbomanage.wordpress.com/2010/01/28/simplify-with-objectify/ David M. Chandler's blog posting about Objectify] and [http://turbomanage.wordpress.com/2010/02/09/generic-dao-for-objectify-2/ Objectify 2]
 * [http://iqbalyusuf.wordpress.com/gwt-uibinder-with-jax-rs-jersey/ GWT Example App with Objectify]
 * [http://groups.google.com/group/objectify-appengine/msg/14a326058a0870be Example of a Cursor based IteratingTask base class]
 * [http://groups.google.com/group/objectify-appengine/browse_thread/thread/afa0d43de5db483f Controlling user access to data with queries]